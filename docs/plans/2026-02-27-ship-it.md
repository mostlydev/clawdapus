# Ship It: CLI Rename, Handle Platforms, Init Migration, Quickstart, Release

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Make Clawdapus installable, usable, and demo-ready for existing OpenClaw users in under 5 minutes — no Go required.

**Architecture:** Flatten the CLI (`claw compose *` → `claw *`), add Telegram/Slack handle support to match OpenClaw's native channels, build a `claw init --from` migration command that scaffolds from existing OpenClaw configs, ship a hello-world quickstart example, and publish prebuilt binaries via GoReleaser + a curl-friendly install script.

**Tech Stack:** Go (Cobra CLI, GoReleaser), GitHub Actions, shell (install.sh)

---

## Task 1: CLI Rename — Promote Subcommands to Root

**Files:**
- Modify: `cmd/claw/compose.go`
- Modify: `cmd/claw/compose_up.go:804-807`
- Modify: `cmd/claw/compose_down.go:30-32`
- Modify: `cmd/claw/compose_ps.go:30-32`
- Modify: `cmd/claw/compose_logs.go:39-41`
- Modify: `cmd/claw/compose_health.go:131-133`
- Modify: `cmd/claw/compose_test.go`
- Modify: `cmd/claw/compose_up_test.go:13-25`

The `composeCmd` Cobra parent goes away. Each subcommand registers directly on `rootCmd`. The `-f` flag moves to each command individually (or a shared persistent flag on root). Error messages update from "claw compose up" to "claw up".

**Step 1: Rewrite `compose.go` — remove parent command, keep shared utility**

Delete the `composeCmd` Cobra command. Keep `composePodFile` var, `resolveComposeGeneratedPath()`, and the `-f` flag — but register the flag on root instead.

```go
// cmd/claw/compose.go — after rename
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

var composePodFile string

func resolveComposeGeneratedPath() (string, error) {
	if composePodFile != "" {
		absPodFile, err := filepath.Abs(composePodFile)
		if err != nil {
			return "", fmt.Errorf("resolve pod file path %q: %w", composePodFile, err)
		}
		generatedPath := filepath.Join(filepath.Dir(absPodFile), "compose.generated.yml")
		if _, err := os.Stat(generatedPath); err != nil {
			return "", fmt.Errorf("no compose.generated.yml found next to %q (run 'claw up %s' first)", composePodFile, composePodFile)
		}
		return generatedPath, nil
	}

	cwd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("resolve current directory: %w", err)
	}

	generatedPath := filepath.Join(cwd, "compose.generated.yml")
	if _, err := os.Stat(generatedPath); err != nil {
		return "", fmt.Errorf("no compose.generated.yml found in %q (rerun from pod directory or pass --file <path-to-claw-pod.yml>)", cwd)
	}
	return generatedPath, nil
}

func init() {
	// Register -f as a persistent flag on root so all lifecycle commands inherit it.
	rootCmd.PersistentFlags().StringVarP(&composePodFile, "file", "f", "", "Path to claw-pod.yml (locates compose.generated.yml next to it)")
}
```

**Step 2: Update each subcommand's `init()` — register on `rootCmd`**

In each file, change `composeCmd.AddCommand(...)` to `rootCmd.AddCommand(...)`:

`compose_up.go` line 806:
```go
// Before:
composeCmd.AddCommand(composeUpCmd)
// After:
rootCmd.AddCommand(composeUpCmd)
```

`compose_down.go` line 31:
```go
rootCmd.AddCommand(composeDownCmd)
```

`compose_ps.go` line 31:
```go
rootCmd.AddCommand(composePsCmd)
```

`compose_logs.go` line 40:
```go
rootCmd.AddCommand(composeLogsCmd)
```

`compose_health.go` line 132:
```go
rootCmd.AddCommand(composeHealthCmd)
```

**Step 3: Update error message in `compose_up.go`**

Line 458:
```go
// Before:
return fmt.Errorf("claw-managed services require detached mode for fail-closed post-apply verification; rerun with 'claw compose up -d %s'", podFile)
// After:
return fmt.Errorf("claw-managed services require detached mode for fail-closed post-apply verification; rerun with 'claw up -d %s'", podFile)
```

**Step 4: Update test error message assertion in `compose_test.go`**

Line 23 — the `resolveComposeGeneratedPath` test checks for an error message that says "claw compose up". After the rename, this error message changes to "claw up", so update the assertion:

```go
// Before:
if !strings.Contains(got, "no compose.generated.yml found in ") || !strings.Contains(got, "(rerun from pod directory or pass --file <path-to-claw-pod.yml>)") {
// After: (same — the default-missing error message doesn't mention "compose")
```

Check the pod-file-missing test too (line 67-80) — the error message in `resolveComposeGeneratedPath` for the `--file` path says `"run 'claw up %s' first"` after Step 1, so no test change needed there since we updated the source.

**Step 5: Run tests**

```bash
go test ./cmd/claw/ -v -run TestResolveCompose
go test ./cmd/claw/ -v -run TestComposeUp
go test ./...
```

Expected: All pass. The tests exercise the functions directly, not through CLI parsing, so the Cobra registration change doesn't affect them.

**Step 6: Verify CLI registration**

```bash
go build -o bin/claw ./cmd/claw && ./bin/claw --help
```

Expected output should show `up`, `down`, `ps`, `logs`, `health` as top-level commands (alongside `build`, `inspect`, `doctor`). No `compose` parent.

**Step 7: Commit**

```bash
git add cmd/claw/compose.go cmd/claw/compose_up.go cmd/claw/compose_down.go cmd/claw/compose_ps.go cmd/claw/compose_logs.go cmd/claw/compose_health.go cmd/claw/compose_test.go cmd/claw/compose_up_test.go
git commit -m "refactor: promote claw compose subcommands to root (claw up/down/ps/logs/health)"
```

---

## Task 2: Update All Documentation for CLI Rename

**Files:**
- Modify: `README.md` (lines 77, 81, 105)
- Modify: `CLAUDE.md` (lines 19, 41, 63)
- Modify: `TESTING.md` (lines 34, 42)
- Modify: `skills/clawdapus/SKILL.md` (lines 24-28, 229, 240, 249, 266)
- Modify: `docs/plans/phase2-progress.md` (lines 25, 49, 243)
- Modify: `docs/reviews/openclaw-architecture-review-2026-02-21.md` (line 31)
- Modify: `cllama-passthrough/README.md` (lines 136, 254)
- Modify: `examples/trading-desk/README.md` (lines 53, 67)

This is a mechanical find-and-replace task across documentation. Each file has specific lines identified.

**Step 1: Update README.md**

Line 77 — change `claw compose up` to `claw up`:
```markdown
`claw build` transpiles the Clawfile to a standard Dockerfile. `claw up` parses the pod YAML, runs driver enforcement, generates per-agent configs, wires the cllama proxy, and calls `docker compose`.
```

Line 81 — change `./bin/claw compose up` to `./bin/claw up`:
```bash
./bin/claw up examples/trading-desk/claw-pod.yml
```

Line 105 — update the comparison table:
```markdown
| `claw up` | `docker compose up` | Enforce + deploy |
```

**Step 2: Update CLAUDE.md**

Line 41 — update the package description comment:
```markdown
- `cmd/claw/compose_up.go` — main orchestration for `claw up`
```

Line 63 — **reverse the decision**:
```markdown
- CLI commands are `claw up/down/ps/logs/health` (not `claw compose up`)
```

**Step 3: Update TESTING.md**

Lines 34 and 42 — replace `claw compose up` with `claw up`.

**Step 4: Update skills/clawdapus/SKILL.md**

Lines 24-28 — rewrite CLI section:
```bash
# Pod lifecycle (mirrors docker compose UX)
claw up [-f <pod>.yml] [-d]      # parse pod, enforce drivers, emit compose.generated.yml, launch
claw down [-f <pod>.yml]         # tear down
claw ps [-f <pod>.yml]           # container status
claw logs [-f <pod>.yml] [svc]   # stream logs
claw health [-f <pod>.yml]       # driver health probes
```

Line 229: `claw up` output
Line 240: `claw health -f <pod>.yml`
Line 249: `claw ps -f <pod>.yml`
Line 266: `claw up` parses pod YAML

Also update line 31:
```
`-f` locates `compose.generated.yml` next to the pod file. Without `-f`, uses `./claw-pod.yml`.
```

**Step 5: Update remaining docs**

- `docs/plans/phase2-progress.md` lines 25, 49: `claw health`; line 243: reverse decision
- `docs/reviews/openclaw-architecture-review-2026-02-21.md` line 31: `claw up`
- `cllama-passthrough/README.md` lines 136, 254: `claw up`
- `examples/trading-desk/README.md` lines 53, 67: `claw up`

**Step 6: Run tests to verify no breakage**

```bash
go test ./...
```

**Step 7: Commit**

```bash
git add README.md CLAUDE.md TESTING.md skills/clawdapus/SKILL.md docs/ cllama-passthrough/README.md examples/trading-desk/README.md
git commit -m "docs: update all references from claw compose to claw up/down/ps/logs/health"
```

---

## Task 3: HANDLE Telegram Support — Driver Config Injection

**Files:**
- Modify: `internal/driver/openclaw/config.go:159-167`
- Modify: `internal/driver/openclaw/config_test.go`

The Slack/Telegram case in `config.go` already has a stub (`channels.<platform>.enabled: true`). Telegram needs:
- Plugin enablement (`plugins.entries.telegram.enabled: true`)
- Token reference (`channels.telegram.token: ${TELEGRAM_BOT_TOKEN}`)
- Bot username injection if available
- Mention patterns (Telegram uses `@username` mentions)
- No guild/channel topology (Telegram has groups, not guilds — simpler model)

**Step 1: Write the failing test**

Add to `internal/driver/openclaw/config_test.go`:

```go
func TestGenerateConfigHandleTelegram(t *testing.T) {
	rc := &driver.ResolvedClaw{
		ServiceName: "news-bot",
		ClawType:    "openclaw",
		Handles: map[string]*driver.HandleInfo{
			"telegram": {
				ID:       "7123456789",
				Username: "newsbot",
			},
		},
		PeerHandles: map[string]map[string]*driver.HandleInfo{},
	}

	config, err := GenerateConfig(rc)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// channels.telegram.enabled
	if v, _ := getPath(config, "channels.telegram.enabled"); v != true {
		t.Error("expected channels.telegram.enabled=true")
	}

	// channels.telegram.token
	if v, _ := getPath(config, "channels.telegram.token"); v != "${TELEGRAM_BOT_TOKEN}" {
		t.Errorf("expected telegram token reference, got %v", v)
	}

	// plugins.entries.telegram.enabled
	if v, _ := getPath(config, "plugins.entries.telegram.enabled"); v != true {
		t.Error("expected plugins.entries.telegram.enabled=true")
	}

	// agents.list with mention patterns
	agentsList, _ := getPath(config, "agents.list")
	agents, ok := agentsList.([]interface{})
	if !ok || len(agents) == 0 {
		t.Fatal("expected agents.list to be populated")
	}
	agent := agents[0].(map[string]interface{})
	if agent["name"] != "Newsbot" {
		t.Errorf("expected agent name 'Newsbot', got %v", agent["name"])
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/driver/openclaw/ -v -run TestGenerateConfigHandleTelegram
```

Expected: FAIL — the stub currently only sets `channels.telegram.enabled: true`, missing token, plugin, and agent list.

**Step 3: Implement Telegram config injection**

In `internal/driver/openclaw/config.go`, replace the `case "slack", "telegram":` stub (lines 159-163) with full implementations:

```go
	case "telegram":
		h := rc.Handles[platform]
		if err := setPath(config, "channels.telegram.enabled", true); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE telegram: %w", err)
		}
		if err := setPath(config, "channels.telegram.token", "${TELEGRAM_BOT_TOKEN}"); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE telegram: %w", err)
		}

		// Mention patterns for Telegram: @username
		var mentionPatterns []string
		if h != nil {
			username := h.Username
			if username == "" {
				username = rc.ServiceName
			}
			if username != "" {
				mentionPatterns = append(mentionPatterns, fmt.Sprintf(`(?i)\b@?%s\b`, regexp.QuoteMeta(username)))
			}
		}

		agentName := rc.ServiceName
		if h != nil && h.Username != "" {
			agentName = strings.ToUpper(h.Username[:1]) + h.Username[1:]
		}
		agentEntry := map[string]interface{}{"id": "main", "name": agentName}
		if len(mentionPatterns) > 0 {
			agentEntry["groupChat"] = map[string]interface{}{
				"mentionPatterns": stringsToIface(mentionPatterns),
			}
		}
		if err := setPath(config, "agents.list", []interface{}{agentEntry}); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE telegram: agents.list: %w", err)
		}

		if err := setPath(config, "plugins.entries.telegram.enabled", true); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE telegram: %w", err)
		}
```

**Step 4: Run tests**

```bash
go test ./internal/driver/openclaw/ -v -run TestGenerateConfigHandleTelegram
go test ./...
```

Expected: All pass.

**Step 5: Commit**

```bash
git add internal/driver/openclaw/config.go internal/driver/openclaw/config_test.go
git commit -m "feat: add Telegram HANDLE support with config injection and mention patterns"
```

---

## Task 4: HANDLE Slack Support — Driver Config Injection

**Files:**
- Modify: `internal/driver/openclaw/config.go` (within the platform switch)
- Modify: `internal/driver/openclaw/config_test.go`

Slack config injection follows the same pattern as Telegram, with workspace-specific topology (Slack has workspaces → channels, similar to Discord's guilds → channels).

**Step 1: Write the failing test**

Add to `internal/driver/openclaw/config_test.go`:

```go
func TestGenerateConfigHandleSlack(t *testing.T) {
	rc := &driver.ResolvedClaw{
		ServiceName: "ops-bot",
		ClawType:    "openclaw",
		Handles: map[string]*driver.HandleInfo{
			"slack": {
				ID:       "U0123456789",
				Username: "opsbot",
			},
		},
		PeerHandles: map[string]map[string]*driver.HandleInfo{},
	}

	config, err := GenerateConfig(rc)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if v, _ := getPath(config, "channels.slack.enabled"); v != true {
		t.Error("expected channels.slack.enabled=true")
	}
	if v, _ := getPath(config, "channels.slack.token"); v != "${SLACK_BOT_TOKEN}" {
		t.Errorf("expected slack token reference, got %v", v)
	}
	if v, _ := getPath(config, "plugins.entries.slack.enabled"); v != true {
		t.Error("expected plugins.entries.slack.enabled=true")
	}

	agentsList, _ := getPath(config, "agents.list")
	agents := agentsList.([]interface{})
	agent := agents[0].(map[string]interface{})
	if agent["name"] != "Opsbot" {
		t.Errorf("expected agent name 'Opsbot', got %v", agent["name"])
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/driver/openclaw/ -v -run TestGenerateConfigHandleSlack
```

**Step 3: Implement Slack config injection**

Add the `case "slack":` block in `config.go` (same structure as Telegram — the platforms diverge mainly in topology, which is already handled generically by the HandleInfo struct):

```go
	case "slack":
		h := rc.Handles[platform]
		if err := setPath(config, "channels.slack.enabled", true); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE slack: %w", err)
		}
		if err := setPath(config, "channels.slack.token", "${SLACK_BOT_TOKEN}"); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE slack: %w", err)
		}

		var mentionPatterns []string
		if h != nil {
			username := h.Username
			if username == "" {
				username = rc.ServiceName
			}
			if username != "" {
				mentionPatterns = append(mentionPatterns, fmt.Sprintf(`(?i)\b@?%s\b`, regexp.QuoteMeta(username)))
			}
			if h.ID != "" {
				mentionPatterns = append(mentionPatterns, fmt.Sprintf(`<@%s>`, h.ID))
			}
		}

		agentName := rc.ServiceName
		if h != nil && h.Username != "" {
			agentName = strings.ToUpper(h.Username[:1]) + h.Username[1:]
		}
		agentEntry := map[string]interface{}{"id": "main", "name": agentName}
		if len(mentionPatterns) > 0 {
			agentEntry["groupChat"] = map[string]interface{}{
				"mentionPatterns": stringsToIface(mentionPatterns),
			}
		}
		if err := setPath(config, "agents.list", []interface{}{agentEntry}); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE slack: agents.list: %w", err)
		}

		if err := setPath(config, "plugins.entries.slack.enabled", true); err != nil {
			return nil, fmt.Errorf("config generation: HANDLE slack: %w", err)
		}
```

**Step 4: Run tests**

```bash
go test ./internal/driver/openclaw/ -v -run TestGenerateConfigHandleSlack
go test ./...
```

**Step 5: Commit**

```bash
git add internal/driver/openclaw/config.go internal/driver/openclaw/config_test.go
git commit -m "feat: add Slack HANDLE support with config injection and mention patterns"
```

---

## Task 5: HANDLE Peer Topology for Telegram + Slack

**Files:**
- Modify: `internal/driver/openclaw/config.go`
- Modify: `internal/driver/openclaw/config_test.go`

Discord has `discordBotIDs()` to collect own + peer IDs for the guild allowlist. Telegram and Slack need equivalent peer discovery so agents in a pod can mention each other cross-platform.

**Step 1: Write the failing test**

```go
func TestGenerateConfigTelegramPeerHandles(t *testing.T) {
	rc := &driver.ResolvedClaw{
		ServiceName: "bot-a",
		ClawType:    "openclaw",
		Handles: map[string]*driver.HandleInfo{
			"telegram": {ID: "111", Username: "bota"},
		},
		PeerHandles: map[string]map[string]*driver.HandleInfo{
			"bot-b": {
				"telegram": {ID: "222", Username: "botb"},
			},
		},
	}

	config, err := GenerateConfig(rc)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify mention patterns include peer patterns
	agentsList, _ := getPath(config, "agents.list")
	agents := agentsList.([]interface{})
	agent := agents[0].(map[string]interface{})
	gc, ok := agent["groupChat"].(map[string]interface{})
	if !ok {
		t.Fatal("expected groupChat to exist")
	}
	patterns := gc["mentionPatterns"].([]interface{})
	if len(patterns) == 0 {
		t.Error("expected mention patterns for telegram handle")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/driver/openclaw/ -v -run TestGenerateConfigTelegramPeerHandles
```

**Step 3: Implement peer topology helpers**

Add `telegramBotIDs()` and `slackBotIDs()` helper functions to `config.go`, following the same pattern as `discordBotIDs()`:

```go
func platformBotIDs(rc *driver.ResolvedClaw, platform string) []string {
	seen := make(map[string]struct{})
	if h := rc.Handles[platform]; h != nil && h.ID != "" {
		seen[h.ID] = struct{}{}
	}
	for _, peerHandles := range rc.PeerHandles {
		if ph, ok := peerHandles[platform]; ok && ph != nil && ph.ID != "" {
			seen[ph.ID] = struct{}{}
		}
	}
	ids := make([]string, 0, len(seen))
	for id := range seen {
		ids = append(ids, id)
	}
	sort.Strings(ids)
	return ids
}
```

Then refactor `discordBotIDs()` to call `platformBotIDs(rc, "discord")` and use the same helper for Telegram/Slack. The Telegram and Slack cases can use `platformBotIDs` to populate any platform-specific allowlists or peer discovery mechanisms.

**Step 4: Run tests**

```bash
go test ./internal/driver/openclaw/ -v
go test ./...
```

**Step 5: Commit**

```bash
git add internal/driver/openclaw/config.go internal/driver/openclaw/config_test.go
git commit -m "feat: generalize peer handle topology for Telegram and Slack"
```

---

## Task 6: `claw init` — Scaffold Command (Bare)

**Files:**
- Create: `cmd/claw/init.go`
- Create: `cmd/claw/init_test.go`

Start with `claw init` (no `--from` flag yet). Generates a starter scaffold in the current directory:
- `Clawfile`
- `claw-pod.yml`
- `AGENTS.md`
- `.env.example`

**Step 1: Write the failing test**

Create `cmd/claw/init_test.go`:

```go
func TestInitScaffoldCreatesFiles(t *testing.T) {
	dir := t.TempDir()
	err := runInit(dir, "")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	for _, name := range []string{"Clawfile", "claw-pod.yml", "AGENTS.md", ".env.example"} {
		path := filepath.Join(dir, name)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			t.Errorf("expected %s to exist", name)
		}
	}
}

func TestInitScaffoldRefusesToOverwrite(t *testing.T) {
	dir := t.TempDir()
	os.WriteFile(filepath.Join(dir, "Clawfile"), []byte("existing"), 0644)

	err := runInit(dir, "")
	if err == nil {
		t.Fatal("expected error when Clawfile already exists")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./cmd/claw/ -v -run TestInitScaffold
```

Expected: FAIL — `runInit` doesn't exist.

**Step 3: Implement `claw init`**

Create `cmd/claw/init.go`:

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var initFromPath string

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Scaffold a new Claw project",
	RunE: func(cmd *cobra.Command, args []string) error {
		dir, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("get working directory: %w", err)
		}
		return runInit(dir, initFromPath)
	},
}

func runInit(dir, fromPath string) error {
	if fromPath != "" {
		return runInitFrom(dir, fromPath)
	}
	return runInitScaffold(dir)
}

func runInitScaffold(dir string) error {
	files := map[string]string{
		"Clawfile": `FROM openclaw:latest

CLAW_TYPE openclaw
AGENT AGENTS.md

MODEL primary openrouter/anthropic/claude-sonnet-4

CLLAMA passthrough

# Uncomment the platforms you use:
# HANDLE discord
# HANDLE telegram
# HANDLE slack
`,
		"claw-pod.yml": `services:
  my-agent:
    image: my-claw:latest
    x-claw:
      agent: ./AGENTS.md
      cllama: passthrough
      cllama-env:
        OPENROUTER_API_KEY: "${OPENROUTER_API_KEY}"
      # Uncomment and configure your platform:
      # handles:
      #   discord:
      #     id: "${DISCORD_BOT_ID}"
      #     username: "my-bot"
      #   telegram:
      #     id: "${TELEGRAM_BOT_ID}"
      #     username: "my_bot"
      #   slack:
      #     id: "${SLACK_BOT_ID}"
      #     username: "my-bot"
    environment:
      # Platform tokens (uncomment as needed):
      # DISCORD_BOT_TOKEN: "${DISCORD_BOT_TOKEN}"
      # TELEGRAM_BOT_TOKEN: "${TELEGRAM_BOT_TOKEN}"
      # SLACK_BOT_TOKEN: "${SLACK_BOT_TOKEN}"
`,
		"AGENTS.md": `# Agent Contract

You are a helpful assistant. Follow these rules:

1. Be concise and direct
2. Stay on topic
3. Ask for clarification when instructions are ambiguous
`,
		".env.example": `# LLM Provider (required — used by cllama proxy, never by agent directly)
OPENROUTER_API_KEY=sk-or-...

# Platform credentials (uncomment the one you use)
# DISCORD_BOT_TOKEN=
# DISCORD_BOT_ID=
# TELEGRAM_BOT_TOKEN=
# TELEGRAM_BOT_ID=
# SLACK_BOT_TOKEN=
# SLACK_BOT_ID=
`,
	}

	// Check for existing files first
	for name := range files {
		path := filepath.Join(dir, name)
		if _, err := os.Stat(path); err == nil {
			return fmt.Errorf("%s already exists; refusing to overwrite (delete it first or use a new directory)", name)
		}
	}

	for name, content := range files {
		path := filepath.Join(dir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			return fmt.Errorf("write %s: %w", name, err)
		}
		fmt.Printf("[claw] created %s\n", name)
	}

	fmt.Println("\n[claw] scaffold ready. Next steps:")
	fmt.Println("  1. cp .env.example .env && edit .env")
	fmt.Println("  2. edit AGENTS.md (your bot's behavioral contract)")
	fmt.Println("  3. claw build -t my-claw .")
	fmt.Println("  4. claw up -d")
	return nil
}

func init() {
	initCmd.Flags().StringVar(&initFromPath, "from", "", "Path to existing OpenClaw config directory to migrate from")
	rootCmd.AddCommand(initCmd)
}
```

**Step 4: Run tests**

```bash
go test ./cmd/claw/ -v -run TestInitScaffold
go test ./...
```

**Step 5: Commit**

```bash
git add cmd/claw/init.go cmd/claw/init_test.go
git commit -m "feat: add claw init command for project scaffolding"
```

---

## Task 7: `claw init --from` — OpenClaw Config Migration

**Files:**
- Modify: `cmd/claw/init.go`
- Modify: `cmd/claw/init_test.go`

Reads an existing OpenClaw config directory, detects channels/models/providers, generates a scaffold pre-populated with the detected configuration.

**Step 1: Write the failing test**

Add to `cmd/claw/init_test.go`:

```go
func TestInitFromOpenClawConfig(t *testing.T) {
	// Create a mock OpenClaw config directory
	srcDir := t.TempDir()
	configDir := filepath.Join(srcDir, "config")
	os.MkdirAll(configDir, 0755)
	os.WriteFile(filepath.Join(configDir, "openclaw.json"), []byte(`{
		"channels": {
			"discord": {"enabled": true, "token": "${DISCORD_BOT_TOKEN}"},
			"telegram": {"enabled": true, "token": "${TELEGRAM_BOT_TOKEN}"}
		},
		"models": {
			"providers": {
				"openrouter": {
					"models": ["anthropic/claude-sonnet-4"]
				}
			}
		}
	}`), 0644)

	destDir := t.TempDir()
	err := runInit(destDir, configDir)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Verify generated Clawfile has detected handles
	clawfile, _ := os.ReadFile(filepath.Join(destDir, "Clawfile"))
	content := string(clawfile)
	if !strings.Contains(content, "HANDLE discord") {
		t.Error("expected Clawfile to contain HANDLE discord")
	}
	if !strings.Contains(content, "HANDLE telegram") {
		t.Error("expected Clawfile to contain HANDLE telegram")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./cmd/claw/ -v -run TestInitFromOpenClawConfig
```

Expected: FAIL — `runInitFrom` doesn't exist or is a stub.

**Step 3: Implement `runInitFrom`**

Add to `cmd/claw/init.go`:

```go
func runInitFrom(dir, fromPath string) error {
	// Look for openclaw.json in the from path or subdirectories
	configPath := findOpenClawConfig(fromPath)
	if configPath == "" {
		return fmt.Errorf("no openclaw.json found in %q or its subdirectories", fromPath)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("read config: %w", err)
	}

	var config map[string]interface{}
	if err := json.Unmarshal(data, &config); err != nil {
		return fmt.Errorf("parse openclaw.json: %w", err)
	}

	// Detect enabled channels
	channels := detectChannels(config)
	models := detectModels(config)

	// Generate scaffold with detected configuration
	return generateMigrationScaffold(dir, channels, models)
}

func findOpenClawConfig(path string) string {
	// Check direct path
	if filepath.Base(path) == "openclaw.json" {
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}
	// Check in path/openclaw.json
	candidate := filepath.Join(path, "openclaw.json")
	if _, err := os.Stat(candidate); err == nil {
		return candidate
	}
	// Check in path/config/openclaw.json
	candidate = filepath.Join(path, "config", "openclaw.json")
	if _, err := os.Stat(candidate); err == nil {
		return candidate
	}
	return ""
}

func detectChannels(config map[string]interface{}) []string {
	channels := make([]string, 0)
	channelsMap, ok := config["channels"].(map[string]interface{})
	if !ok {
		return channels
	}
	for platform, v := range channelsMap {
		m, ok := v.(map[string]interface{})
		if !ok {
			continue
		}
		if enabled, ok := m["enabled"].(bool); ok && enabled {
			channels = append(channels, platform)
		}
	}
	sort.Strings(channels)
	return channels
}

func detectModels(config map[string]interface{}) []string {
	models := make([]string, 0)
	providers, ok := getNestedMap(config, "models", "providers")
	if !ok {
		return models
	}
	for providerID, v := range providers {
		m, ok := v.(map[string]interface{})
		if !ok {
			continue
		}
		modelList, ok := m["models"].([]interface{})
		if !ok {
			continue
		}
		for _, model := range modelList {
			if s, ok := model.(string); ok {
				models = append(models, providerID+"/"+s)
			}
		}
	}
	return models
}

func getNestedMap(m map[string]interface{}, keys ...string) (map[string]interface{}, bool) {
	current := m
	for _, key := range keys {
		next, ok := current[key].(map[string]interface{})
		if !ok {
			return nil, false
		}
		current = next
	}
	return current, true
}
```

Then `generateMigrationScaffold` builds the same files as `runInitScaffold` but with detected channels uncommented and models pre-populated.

**Step 4: Run tests**

```bash
go test ./cmd/claw/ -v -run TestInitFrom
go test ./...
```

**Step 5: Commit**

```bash
git add cmd/claw/init.go cmd/claw/init_test.go
git commit -m "feat: add claw init --from for OpenClaw config migration"
```

---

## Task 8: Hello-World Quickstart Example

**Files:**
- Create: `examples/quickstart/README.md`
- Create: `examples/quickstart/Clawfile`
- Create: `examples/quickstart/claw-pod.yml`
- Create: `examples/quickstart/AGENTS.md`
- Create: `examples/quickstart/.env.example`

**Step 1: Create the quickstart directory**

```bash
mkdir -p examples/quickstart
```

**Step 2: Create `examples/quickstart/Clawfile`**

```dockerfile
FROM openclaw:latest

CLAW_TYPE openclaw
AGENT AGENTS.md

MODEL primary openrouter/anthropic/claude-sonnet-4

CLLAMA passthrough
```

**Step 3: Create `examples/quickstart/AGENTS.md`**

```markdown
# Quickstart Agent

You are a helpful assistant running inside a governed Clawdapus container.

## Rules

1. Be concise and helpful
2. When asked about your infrastructure, explain that you run inside a governed container with credential starvation — you cannot access LLM provider keys directly
3. Mention that your behavioral contract (this file) is mounted read-only and cannot be modified even with root access
```

**Step 4: Create `examples/quickstart/claw-pod.yml`**

```yaml
services:
  assistant:
    image: quickstart-claw:latest
    x-claw:
      agent: ./AGENTS.md
      cllama: passthrough
      cllama-env:
        OPENROUTER_API_KEY: "${OPENROUTER_API_KEY}"
    environment:
      # Uncomment ONE platform:
      # DISCORD_BOT_TOKEN: "${DISCORD_BOT_TOKEN}"
      # TELEGRAM_BOT_TOKEN: "${TELEGRAM_BOT_TOKEN}"
      # SLACK_BOT_TOKEN: "${SLACK_BOT_TOKEN}"
```

**Step 5: Create `examples/quickstart/.env.example`**

```bash
# Required: LLM provider key (proxy only — agent never sees this)
OPENROUTER_API_KEY=sk-or-...

# Optional: uncomment ONE platform
# DISCORD_BOT_TOKEN=
# TELEGRAM_BOT_TOKEN=
# SLACK_BOT_TOKEN=
```

**Step 6: Create `examples/quickstart/README.md`**

```markdown
# Clawdapus Quickstart

Get a governed OpenClaw agent running in 5 minutes.

## Prerequisites

- Docker Desktop running
- An OpenClaw base image (`openclaw:latest`)
- An OpenRouter API key (or Anthropic/OpenAI key)
- A bot token for your platform (Discord, Telegram, or Slack)

## 1. Install Clawdapus

curl -sSL https://raw.githubusercontent.com/mostlydev/clawdapus/master/install.sh | sh

## 2. Set up credentials

cp .env.example .env
# Edit .env — add your OPENROUTER_API_KEY and platform bot token

## 3. Build

source .env
claw build -t quickstart-claw .

## 4. Run

claw up -d

## 5. Verify

claw ps          # Both assistant + cllama-passthrough should be running
claw health      # Both should show healthy

Open http://localhost:8081 for the cllama proxy dashboard.
You'll see every LLM call with token counts and cost tracking.

## 6. Talk to your bot

Use your platform (Discord/Telegram/Slack) to message your bot.
Every message routes through the cllama proxy — the bot has no direct API access.

## What's happening

- **Credential starvation:** Your API key is in the proxy only. The agent has a bearer token. It cannot call providers directly.
- **Behavioral contract:** `AGENTS.md` is mounted read-only. Even root inside the container can't change it.
- **Cost tracking:** The proxy logs every request with token usage and estimated cost.
- **Audit trail:** `claw logs cllama-passthrough` shows structured JSON audit logs.

## Migrate from existing OpenClaw

Already have an OpenClaw bot running? Import your config:

claw init --from ~/path/to/openclaw/config
# Generates Clawfile, claw-pod.yml, AGENTS.md pre-configured from your setup

## Clean up

claw down
```

**Step 7: Update root README.md examples table**

Add quickstart to the examples table in `README.md`:

```markdown
| [`examples/quickstart/`](./examples/quickstart/) | 5-minute quickstart — single governed agent with cllama proxy |
```

**Step 8: Commit**

```bash
git add examples/quickstart/ README.md
git commit -m "feat: add quickstart example for 5-minute governed agent setup"
```

---

## Task 9: GoReleaser Configuration

**Files:**
- Create: `.goreleaser.yml`
- Create: `.github/workflows/release.yml`

**Step 1: Create `.goreleaser.yml`**

```yaml
version: 2

project_name: clawdapus

before:
  hooks:
    - go mod tidy
    - go vet ./...
    - go test ./...

builds:
  - id: claw
    main: ./cmd/claw
    binary: claw
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
    goarch:
      - amd64
      - arm64
    ldflags:
      - -s -w -X main.version={{.Version}} -X main.commit={{.Commit}}

archives:
  - id: claw
    builds:
      - claw
    format: tar.gz
    name_template: "clawdapus_{{ .Version }}_{{ .Os }}_{{ .Arch }}"

checksum:
  name_template: "checksums.txt"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"
```

**Step 2: Add version variable to `cmd/claw/root.go`**

```go
package main

import (
	"fmt"

	"github.com/spf13/cobra"
)

var version = "dev"
var commit = "none"

var rootCmd = &cobra.Command{
	Use:          "claw",
	Short:        "Infrastructure-layer governance for AI agent containers",
	SilenceUsage: true,
	Version:      fmt.Sprintf("%s (%s)", version, commit),
}
```

**Step 3: Create `.github/workflows/release.yml`**

```yaml
name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
      - uses: goreleaser/goreleaser-action@v6
        with:
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Step 4: Test GoReleaser locally (dry run)**

```bash
goreleaser check
goreleaser build --snapshot --clean
```

Expected: Builds binaries for all targets in `dist/`.

If you don't have goreleaser installed: `go install github.com/goreleaser/goreleaser/v2@latest` or `brew install goreleaser`.

**Step 5: Commit**

```bash
git add .goreleaser.yml .github/workflows/release.yml cmd/claw/root.go
git commit -m "feat: add GoReleaser config and GitHub Actions release workflow"
```

---

## Task 10: Install Script

**Files:**
- Create: `install.sh`

**Step 1: Write the install script**

Create `install.sh`:

```bash
#!/bin/sh
set -e

# Clawdapus installer — downloads prebuilt binary from GitHub Releases.
# Usage: curl -sSL https://raw.githubusercontent.com/mostlydev/clawdapus/master/install.sh | sh

REPO="mostlydev/clawdapus"
INSTALL_DIR="${CLAW_INSTALL_DIR:-$HOME/.local/bin}"

# Detect platform
OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
  x86_64)  ARCH="amd64" ;;
  aarch64) ARCH="arm64" ;;
  arm64)   ARCH="arm64" ;;
  *)
    echo "Error: unsupported architecture: $ARCH"
    exit 1
    ;;
esac

case "$OS" in
  linux|darwin) ;;
  *)
    echo "Error: unsupported OS: $OS"
    exit 1
    ;;
esac

# Get latest release tag
LATEST=$(curl -sSL "https://api.github.com/repos/${REPO}/releases/latest" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
if [ -z "$LATEST" ]; then
  echo "Error: could not determine latest release"
  exit 1
fi

VERSION="${LATEST#v}"
TARBALL="clawdapus_${VERSION}_${OS}_${ARCH}.tar.gz"
URL="https://github.com/${REPO}/releases/download/${LATEST}/${TARBALL}"

echo "Installing claw ${LATEST} (${OS}/${ARCH})..."

# Download and extract
TMPDIR=$(mktemp -d)
trap 'rm -rf "$TMPDIR"' EXIT

curl -sSL "$URL" -o "${TMPDIR}/${TARBALL}"
tar -xzf "${TMPDIR}/${TARBALL}" -C "$TMPDIR"

# Install binary
mkdir -p "$INSTALL_DIR"
mv "${TMPDIR}/claw" "${INSTALL_DIR}/claw"
chmod +x "${INSTALL_DIR}/claw"

echo "Installed claw to ${INSTALL_DIR}/claw"

# Check if install dir is in PATH
case ":$PATH:" in
  *":${INSTALL_DIR}:"*) ;;
  *)
    echo ""
    echo "Add to your PATH:"
    echo "  export PATH=\"${INSTALL_DIR}:\$PATH\""
    echo ""
    echo "Or move the binary:"
    echo "  sudo mv ${INSTALL_DIR}/claw /usr/local/bin/claw"
    ;;
esac

echo ""
echo "Verify: claw doctor"
echo "Get started: claw init"
```

**Step 2: Test the script structure**

```bash
chmod +x install.sh
shellcheck install.sh  # if available
```

**Step 3: Update README.md install section**

Replace the current "Install AI Skill" section at the top with:

```markdown
## Install

```bash
curl -sSL https://raw.githubusercontent.com/mostlydev/clawdapus/master/install.sh | sh
claw doctor
```

Or build from source:

```bash
go build -o bin/claw ./cmd/claw
```
```

Keep the AI Skill section but move it below Install.

**Step 4: Commit**

```bash
git add install.sh README.md
git commit -m "feat: add curl-friendly install script and update README"
```

---

## Task 11: Final Integration Verification

**Files:** None — this is a verification-only task.

**Step 1: Run full test suite**

```bash
go test ./...
go vet ./...
```

Expected: All pass.

**Step 2: Verify CLI help**

```bash
go build -o bin/claw ./cmd/claw
./bin/claw --help
./bin/claw --version
./bin/claw init --help
./bin/claw up --help
```

Expected: Clean help output. `up`, `down`, `ps`, `logs`, `health`, `init`, `build`, `inspect`, `doctor` all appear as top-level commands. No `compose` parent.

**Step 3: Verify GoReleaser**

```bash
goreleaser check
goreleaser build --snapshot --clean
ls dist/
```

Expected: Binaries for darwin_amd64, darwin_arm64, linux_amd64, linux_arm64.

**Step 4: Verify quickstart example files are valid**

```bash
cat examples/quickstart/Clawfile
cat examples/quickstart/claw-pod.yml
```

Eyeball: Clawfile uses valid directives, claw-pod.yml is valid YAML with correct `x-claw` structure.

**Step 5: Commit any fixes, then tag**

```bash
git tag v0.1.0
```

Do NOT push the tag until ready to publish the first release. Pushing the tag triggers the GitHub Action.
