# clawctl — Fleet Dashboard Design

**Date:** 2026-02-28
**Status:** IMPLEMENTED

## Overview

`clawctl` is a standalone operator-facing container auto-injected into every Clawdapus pod. It provides fleet-level observability: a single pane of glass showing all agents, services, cllama proxies, surfaces, and their live health status.

## Architecture

### Container Model

- **Service name:** `clawctl`
- **Image:** `ghcr.io/mostlydev/clawctl:latest` (Go binary, embedded HTML templates)
- **Port:** `:8082` (configurable via `CLAWCTL_ADDR`)
- **Hardening:** `read_only: true`, `tmpfs: [/tmp]`, `restart: on-failure` — same as all claw services
- **Network:** `claw-internal`
- **Labels:** `claw.pod: <pod-name>`, `claw.role: dashboard`

### Data Sources

Two complementary inputs:

1. **`/claw/pod-manifest.json`** (read-only bind mount) — Generated by `compose_up.go` during the materialize pass. Contains the full resolved pod topology as a static snapshot:
   - Per-service: name, clawType, imageRef, agent file, models, count
   - Handles: platform, ID, username, guilds (with channels)
   - Surfaces: scheme, target, accessMode, ports, channelConfig
   - Skills: name list
   - Invocations: schedule, message, to, name
   - Cllama: proxy types, proxy service names
   - Peer relationships: peerHandles map

2. **`/var/run/docker.sock`** (read-only bind mount) — Live container status via Docker API:
   - Container state: running, stopped, restarting
   - Health check results: healthy, unhealthy, starting
   - Uptime duration
   - No exec, no lifecycle ops — strictly read-only

### Injection into Compose

Same pattern as cllama sidecar injection in `compose_emit.go`. A new `ClawctlConfig` struct passed to `EmitCompose`, which adds the `clawctl` service entry to `compose.generated.yml`. Always injected when the pod has any `x-claw` services (same `hasClaw` gate).

### Manifest Generation

During `claw up`, after Pass 1 (inspect + resolve all services) but before Pass 2 (materialize), `compose_up.go` serializes the resolved pod state into `pod-manifest.json` in the runtime dir. This is a JSON serialization of:

```go
type PodManifest struct {
    PodName   string                    `json:"podName"`
    Services  map[string]ServiceManifest `json:"services"`
    Proxies   []ProxyManifest           `json:"proxies"`
}

type ServiceManifest struct {
    ClawType    string                          `json:"clawType"`
    ImageRef    string                          `json:"imageRef"`
    Agent       string                          `json:"agent"`
    Models      map[string]string               `json:"models,omitempty"`
    Count       int                             `json:"count"`
    Handles     map[string]*driver.HandleInfo   `json:"handles,omitempty"`
    Surfaces    []SurfaceManifest               `json:"surfaces,omitempty"`
    Skills      []string                        `json:"skills,omitempty"`
    Invocations []driver.Invocation             `json:"invocations,omitempty"`
    Cllama      []string                        `json:"cllama,omitempty"`
}

type SurfaceManifest struct {
    Scheme     string `json:"scheme"`
    Target     string `json:"target"`
    AccessMode string `json:"accessMode,omitempty"`
    Ports      []string `json:"ports,omitempty"`
}

type ProxyManifest struct {
    ProxyType   string `json:"proxyType"`
    ServiceName string `json:"serviceName"`
    Image       string `json:"image"`
}
```

Skills are serialized as name-only (no host paths — those are meaningless inside the dashboard container).

## Pages

### 1. Fleet Overview (`/`)

The home page. A card grid showing every service in the pod.

**Card grouping** (section headers):
- **Agents** — services with a clawType (openclaw, nanoclaw, etc.)
- **Proxies** — cllama services
- **Infrastructure** — non-claw services (databases, caches, etc.)

**Agent card contents:**
- Service name (bold) + claw type badge (small pill)
- Health status: green/amber/red dot + status text (healthy, unhealthy, starting, stopped)
- Model: primary model slot value (e.g. `anthropic/claude-sonnet-4-20250514`)
- Handles: platform icon(s) + username (e.g. Discord icon + `@fleet-bot`)
- Cllama indicator: proxy type badge if proxied (e.g. `passthrough`)
- Uptime: human-readable duration
- Count: ordinal badge if count > 1 (e.g. `x3`)

**Proxy card contents:**
- Service name + `proxy` role badge
- Health dot + status
- Proxy type
- Uptime

**Infrastructure card contents:**
- Service name + `native` badge
- Health dot (from Docker healthcheck if configured)
- Uptime

**Click action:** Navigates to `/detail/<service-name>`

### 2. Topology (`/topology`)

Layered column wiring diagram showing how pod components connect.

**Five swim lanes (left to right):**

```
Channels  │  Agents  │  Proxies  │  Services  │  Volumes
──────────┼──────────┼───────────┼────────────┼─────────
discord   ─── bot-a  ─── cllama  │            │ shared-data
discord   ─── bot-b  ─┘          ─── postgres │
          └── bot-c              │            └ workspace
```

**Implementation:**
- HTML nodes positioned in CSS grid columns
- SVG `<line>` or `<path>` elements for connections, drawn between node edges
- Color-coded by surface scheme:
  - Cyan (`--cyan`) for channel surfaces
  - Amber (`--amber`) for service surfaces
  - Green (`--green`) for volume/host surfaces
  - Purple (`--purple`) for cllama proxy links
- Hover: highlighting a node dims all unconnected nodes/lines (CSS opacity transition)
- Health dots on each node (same as fleet cards)

**Data flow:** Derived entirely from `pod-manifest.json` — surfaces define the edges, services define the nodes. Proxies appear in the middle column based on each agent's `cllama` field. Channels/services/volumes appear based on surface scheme.

**No JS framework.** Pure HTML + inline SVG + CSS. Connection line coordinates computed server-side in Go template rendering (node positions are deterministic from the grid layout).

### 3. Detail (`/detail/:service`)

Drill-down view for a single service. Sections rendered as collapsible panels:

| Section | Content |
|---------|---------|
| **Status** | Health dot, status text, uptime, container ID (short), image ref |
| **Surfaces** | Table: scheme, target, access mode, ports |
| **Handles** | Table: platform, username, ID, guilds (expandable with channels) |
| **Skills** | Bulleted list of skill names |
| **Invoke** | Table: name, cron schedule, message (truncated), target channel |
| **Models** | Table: slot, provider/model |
| **Cllama** | Proxy type(s), proxy service name, token status (present/absent — never shown) |

## Visual Design

Inherits cllama's design language for visual cohesion across the pod's operator tools:

- **Fonts:** Geist Mono (monospace, labels/badges), Outfit (sans-serif, body text)
- **Color palette:** Same CSS variables — `--bg: #0c1017`, `--cyan: #22d3ee`, `--amber: #f0a500`, `--green: #34d399`, `--red: #ef4444`, `--purple: #a78bfa`
- **Scan-line overlay:** Same subtle `repeating-linear-gradient` texture
- **Top bar:** `CLAWCTL` brand in Geist Mono uppercase, nav tabs (Fleet / Topology / Detail)
- **Cards:** `--bg-raised` background, `--line` border, subtle hover glow
- **Badges/pills:** Rounded, small, colored by type (cyan for claw types, amber for proxy, green for native)

## Live Updates

Smooth partial refresh without full-page reloads:

- A small `<script>` block (~20 lines) runs `fetch()` against a JSON endpoint (`/api/status`) every 15 seconds
- Response contains per-service health status, uptime, and container state
- JS updates only the health dots, status text, and uptime values in-place
- No DOM thrashing — targeted `textContent` and `className` updates
- Scroll position and any expanded detail sections are preserved
- Fleet and topology pages both use this mechanism
- Detail page also polls for the single service's status

Fallback: if JS is disabled, a `<noscript>` block shows a manual refresh link. The pages are fully functional without JS — just static snapshots.

## Non-Goals (v1)

- **Log streaming** — `claw logs` covers this from CLI
- **Health timeline / history** — Future enhancement, needs persistent storage
- **Config editing** — clawctl is read-only; config changes go through `claw-pod.yml`
- **Cost tracking** — Lives in cllama's dashboard (`:8081`); clawctl links to it
- **Authentication** — Pod-internal only (not exposed to the internet by default)

## Implementation Sequence

1. **Manifest generation** — Add `PodManifest` types, serialize in `compose_up.go` after Pass 1
2. **Compose injection** — Add `ClawctlConfig` to `EmitCompose`, inject `clawctl` service
3. **Go binary scaffold** — `clawctl/` directory (same repo), HTTP server, Docker API client, template rendering
4. **Fleet page** — Card grid with live health polling
5. **Topology page** — Layered column diagram with SVG connections
6. **Detail page** — Service drill-down panels
7. **Image build** — Dockerfile, CI, `ghcr.io/mostlydev/clawctl:latest`
