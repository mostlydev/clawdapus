package openclaw

import (
	"fmt"
	"sort"
	"strings"

	"github.com/mostlydev/clawdapus/internal/driver"
	"github.com/mostlydev/clawdapus/internal/driver/shared"
)

// GenerateClawdapusMD builds the CLAWDAPUS.md context file — the infrastructure
// layer's letter to the agent. Contains identity, surfaces, and skill index.
// Injected into the agent's context via bootstrap-extra-files hook.
func GenerateClawdapusMD(rc *driver.ResolvedClaw, podName string) string {
	var b strings.Builder

	b.WriteString("# CLAWDAPUS.md\n\n")
	b.WriteString("This file is generated by Clawdapus. It describes your infrastructure environment.\n\n")

	// Identity
	b.WriteString("## Identity\n\n")
	b.WriteString(fmt.Sprintf("- **Pod:** %s\n", podName))
	b.WriteString(fmt.Sprintf("- **Service:** %s\n", rc.ServiceName))
	b.WriteString(fmt.Sprintf("- **Type:** %s\n", rc.ClawType))
	b.WriteString("\n")

	// Surfaces
	b.WriteString("## Surfaces\n\n")
	if len(rc.Surfaces) == 0 {
		b.WriteString("No surfaces declared for this service.\n\n")
	} else {
		for _, s := range rc.Surfaces {
			b.WriteString(fmt.Sprintf("### %s (%s)\n", s.Target, s.Scheme))
			if s.AccessMode != "" {
				b.WriteString(fmt.Sprintf("- **Access:** %s\n", s.AccessMode))
			}
			switch s.Scheme {
			case "volume":
				b.WriteString(fmt.Sprintf("- **Mount path:** /mnt/%s\n", s.Target))
			case "service":
				b.WriteString(fmt.Sprintf("- **Host:** %s\n", s.Target))
				b.WriteString(fmt.Sprintf("- **Skill:** `skills/surface-%s.md`\n", s.Target))
			case "channel":
				if tokenVar := shared.PlatformTokenVar(s.Target); tokenVar != "" {
					b.WriteString(fmt.Sprintf("- **Token:** `%s` (env)\n", tokenVar))
				}
				b.WriteString(fmt.Sprintf("- **Skill:** `skills/surface-%s.md`\n", s.Target))
			}
			b.WriteString("\n")
		}
	}

	if len(rc.Cllama) > 0 {
		b.WriteString("## LLM Proxy\n\n")
		b.WriteString("Your LLM requests are routed through a governance proxy.\n\n")
		firstProxy := fmt.Sprintf("cllama-%s", rc.Cllama[0])
		b.WriteString(fmt.Sprintf("- **Endpoint:** `http://%s:8080/v1`\n", firstProxy))
		b.WriteString("- **Auth:** Bearer token (pre-configured)\n")
		if len(rc.Cllama) == 1 {
			b.WriteString(fmt.Sprintf("- **Mode:** %s\n", rc.Cllama[0]))
		} else {
			b.WriteString(fmt.Sprintf("- **Chain:** %s\n", strings.Join(rc.Cllama, " -> ")))
		}
		b.WriteString("\nAll inference requests pass through this proxy for logging and policy enforcement.\n")
		b.WriteString("You do not need to configure this - model settings are pre-wired.\n\n")
	}

	// Handles
	if len(rc.Handles) > 0 {
		b.WriteString("## Handles\n\n")
		b.WriteString("Your channel identities on social platforms. Other agents use these to reach you.\n\n")

		// Sort platform names for determinism
		platforms := make([]string, 0, len(rc.Handles))
		for p := range rc.Handles {
			platforms = append(platforms, p)
		}
		sort.Strings(platforms)

		for _, platform := range platforms {
			info := rc.Handles[platform]
			if info == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("### %s\n", platform))
			b.WriteString(fmt.Sprintf("- **ID:** %s\n", info.ID))
			if info.Username != "" {
				b.WriteString(fmt.Sprintf("- **Username:** %s\n", info.Username))
			}
			for _, guild := range info.Guilds {
				guildLine := fmt.Sprintf("- **Guild:** %s", guild.ID)
				if guild.Name != "" {
					guildLine += fmt.Sprintf(" (%s)", guild.Name)
				}
				b.WriteString(guildLine + "\n")
				for _, ch := range guild.Channels {
					chLine := fmt.Sprintf("  - **Channel:** %s", ch.ID)
					if ch.Name != "" {
						chLine += fmt.Sprintf(" (#%s)", ch.Name)
					}
					b.WriteString(chLine + "\n")
				}
			}
			b.WriteString("\n")
		}
	}

	// Skills index
	b.WriteString("## Skills\n\n")
	var skillEntries []string

	// Handle skills (one per declared platform)
	if len(rc.Handles) > 0 {
		handlePlatforms := make([]string, 0, len(rc.Handles))
		for p := range rc.Handles {
			handlePlatforms = append(handlePlatforms, p)
		}
		sort.Strings(handlePlatforms)
		for _, p := range handlePlatforms {
			skillEntries = append(skillEntries, fmt.Sprintf("- `skills/handle-%s.md` — %s channel identity", p, p))
		}
	}

	// Surface-generated skills (service and channel surfaces)
	for _, s := range rc.Surfaces {
		switch s.Scheme {
		case "service":
			skillEntries = append(skillEntries, fmt.Sprintf("- `skills/surface-%s.md` — %s service surface", s.Target, s.Target))
		case "channel":
			skillEntries = append(skillEntries, fmt.Sprintf("- `skills/surface-%s.md` — %s channel surface", s.Target, s.Target))
		}
	}

	// Operator-provided skills (exclude auto-generated handle-* and surface-* files)
	for _, sk := range rc.Skills {
		if strings.HasPrefix(sk.Name, "handle-") || strings.HasPrefix(sk.Name, "surface-") {
			continue
		}
		skillEntries = append(skillEntries, fmt.Sprintf("- `skills/%s` — operator-provided skill", sk.Name))
	}

	if len(skillEntries) == 0 {
		b.WriteString("No skills available.\n")
	} else {
		for _, entry := range skillEntries {
			b.WriteString(entry + "\n")
		}
	}

	return b.String()
}
